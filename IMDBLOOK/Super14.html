<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Run, Yon!</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: lightblue;
            font-family: 'Press Start 2P', cursive;
        }
        canvas {
            display: block;
            background-color: lightblue;
            border-bottom: 5px solid green;
        }
        .ground {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 50px;
            background-color: green;
            background-image: repeating-linear-gradient(90deg, brown 0px, brown 10px, green 10px, green 20px);
        }
        #restartButton {
            display: none;
            position: absolute;
            left: 50%;
            top: 60%;
            transform: translate(-50%, -50%);
            padding: 10px 20px;
            font-size: 20px;
            color: white;
            background-color: green;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        @font-face {
            font-family: 'Press Start 2P';
            src: url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="ground"></div>
<button id="restartButton">התחל מחדש</button>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const restartButton = document.getElementById('restartButton');

    // Set canvas dimensions
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 50; // Subtract ground height

    const X = 50; // Character's height and obstacle dimensions
    const gravity = 0.8;
    const jumpHeight = 15;
    let score = 0;
    let obstacles = [];
    let frameCount = 0;
    let isGameOver = false;
    let startTouchY = 0; // Y position of the touch start
    let obstacleSpeed = 5; // Speed of obstacles
    let groundOffset = 0; // Ground movement offset
    let speedIncreaseInterval = 10000; // 10 seconds
    let lastSpeedIncreaseTime = Date.now(); // Last time speed was increased

    // Main character object
    const yon = {
        x: 100,
        y: canvas.height - X,
        width: X,
        height: X,
        dy: 0,
        isJumping: false,
        isCrouching: false,
        jump() {
            if (!this.isJumping && !this.isCrouching) {
                this.dy = -jumpHeight;
                this.isJumping = true;
            }
        },
        crouch() {
            this.isCrouching = true;
            this.height = X / 2;
        },
        standUp() {
            this.isCrouching = false;
            this.height = X;
        },
        update() {
            this.y += this.dy;
            if (this.y + this.height < canvas.height) {
                this.dy += gravity;
            } else {
                this.dy = 0;
                this.isJumping = false;
                this.y = canvas.height - this.height;
            }
        },
        draw() {
            ctx.fillStyle = 'blue';
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    };

    // Obstacle class
    class Obstacle {
        constructor(type) {
            this.type = type;
            this.x = canvas.width;
            this.width = X;
            this.speed = obstacleSpeed;
            if (type === 'rock') {
                this.height = X / 2;
                this.y = Math.random() > 0.5 ? canvas.height - X / 2 : canvas.height - X;
            } else if (type === 'hedgehog') {
                this.height = X / 2;
                this.y = canvas.height - this.height;
            } else if (type === 'pipe') {
                this.height = canvas.height - X / 2; // From top to just above the ground
                this.y = 0;
            }
        }
        update() {
            this.x -= this.speed;
        }
        draw() {
            ctx.fillStyle = this.type === 'rock' ? 'gray' : this.type === 'hedgehog' ? 'brown' : 'green';
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    }

    // Draw moving ground
    function drawMovingGround() {
        groundOffset -= obstacleSpeed; // Move ground at the same speed as obstacles
        if (groundOffset <= -20) { // Recycle pattern
            groundOffset = 0;
        }
        ctx.fillStyle = 'green';
        ctx.fillRect(0, canvas.height - 50, canvas.width, 50); // Base ground layer
        ctx.save();
        ctx.translate(groundOffset, 0);
        ctx.fillStyle = 'brown';
        for (let i = 0; i < canvas.width / 20; i++) {
            ctx.fillRect(i * 20, canvas.height - 50, 10, 50); // Draw repeating ground pattern
        }
        ctx.restore();
    }

    // Handle touch input
    window.addEventListener('touchstart', (e) => {
        startTouchY = e.touches[0].clientY;
    });

    window.addEventListener('touchmove', (e) => {
        const touchY = e.touches[0].clientY;
        const deltaY = touchY - startTouchY;

        if (deltaY < -30) {  // Swipe up
            yon.jump();
        } else if (deltaY > 30) {  // Swipe down
            yon.crouch();
        }
    });

    window.addEventListener('touchend', () => {
        yon.standUp();
    });

    // Reset game
    function resetGame() {
        isGameOver = false;
        score = 0;
        frameCount = 0;
        obstacles = [];
        yon.y = canvas.height - yon.height;
        restartButton.style.display = 'none';
        update(); // Restart game loop
    }

    restartButton.addEventListener('click', resetGame);

    function generateObstacle() {
        const type = Math.random() > 0.5 ? 'rock' : Math.random() > 0.5 ? 'hedgehog' : 'pipe'; // Include the new 'pipe' obstacle
        obstacles.push(new Obstacle(type));
    }

    function updateScore() {
        score++;
        ctx.fillStyle = 'black';
        ctx.font = '24px Arial';
        ctx.fillText(`Score: ${score}`, 20, 40);
    }

    function checkCollision() {
        for (let i = 0; i < obstacles.length; i++) {
            const obs = obstacles[i];
            if (yon.x < obs.x + obs.width &&
                yon.x + yon.width > obs.x &&
                yon.y < obs.y + obs.height &&
                yon.y + yon.height > obs.y) {
                isGameOver = true;
            }
        }
    }

    // Increase speed every 10 seconds
    function increaseSpeed() {
        const currentTime = Date.now();
        if (currentTime - lastSpeedIncreaseTime > speedIncreaseInterval) {
            obstacleSpeed += 0.2;
            lastSpeedIncreaseTime = currentTime;
        }
    }

    function update() {
        if (isGameOver) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = 'red';
            ctx.font = '48px Arial';
            ctx.fillText('Game Over', canvas.width / 2 - 100, canvas.height / 2);

            // Show restart button
            restartButton.style.display = 'block';
            return;
        }

        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw moving ground
        drawMovingGround();

        // Update and draw main character
        yon.update();
        yon.draw();

        // Generate obstacles
        if (frameCount % 100 === 0) {
            generateObstacle();
        }

        // Update and draw obstacles
        for (let i = 0; i < obstacles.length; i++) {
            obstacles[i].speed = obstacleSpeed; // Update obstacle speed
            obstacles[i].update();
            obstacles[i].draw();
        }

        // Check for collisions
        checkCollision();

        // Update score
        updateScore();

        // Increase speed if needed
        increaseSpeed();

        frameCount++;
        requestAnimationFrame(update);
    }

    update();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Run, Yon!</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: lightblue;
            font-family: 'Press Start 2P', cursive;
        }
        canvas {
            display: block;
            background-color: lightblue;
            border-bottom: 5px solid green;
        }
        .ground {
            position: absolute;
            bottom: 0;
            width: 200%; /* הרחבנו את רוחב הקרקע לתנועה רציפה */
            height: 50px;
            background-color: green;
            background-image: repeating-linear-gradient(90deg, brown 0px, brown 10px, green 10px, green 20px);
        }
        #restartButton {
            display: none;
            position: absolute;
            left: 50%;
            top: 60%;
            transform: translate(-50%, -50%);
            padding: 10px 20px;
            font-size: 20px;
            color: white;
            background-color: green;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        @font-face {
            font-family: 'Press Start 2P';
            src: url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        }
    </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div class="ground" id="ground"></div>
<button id="restartButton">התחל מחדש</button>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const restartButton = document.getElementById('restartButton');
    const ground = document.getElementById('ground');

    // Set canvas dimensions
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight - 50; // Subtract ground height

    const X = 50; // Character's height and obstacle dimensions
    const gravity = 0.9;
    const jumpHeight = 15;
    let score = 0;
    let highScore = 0;
    let obstacles = [];
    let frameCount = 0;
    let isGameOver = false;
    let startTouchY = 0; // Y position of the touch start
    let obstacleSpeed = 5; // Starting speed of obstacles
    let speedIncrementInterval = 10000; // 10 seconds
    let lastSpeedIncreaseTime = 0; // Last time the speed increased
    let groundOffset = 0; // Ground offset for animation

    // Main character object
    const yon = {
        x: 100,
        y: canvas.height - X,
        width: X,
        height: X,
        dy: 0,
        isJumping: false,
        isCrouching: false,
        jump() {
            if (!this.isJumping && !this.isCrouching) {
                this.dy = -jumpHeight;
                this.isJumping = true;
            }
        },
        crouch() {
            this.isCrouching = true;
            this.height = X / 2;
            this.y = canvas.height - this.height; // Adjust Y based on new height
        },
        standUp() {
            this.isCrouching = false;
            this.height = X;
            this.y = canvas.height - this.height; // Reset Y based on height
        },
        update() {
            this.y += this.dy;
            if (this.y + this.height < canvas.height) {
                this.dy += gravity;
            } else {
                this.dy = 0;
                this.isJumping = false;
                this.y = canvas.height - this.height;
            }
        },
        draw() {
            ctx.fillStyle = 'blue';
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    };

    // Obstacle class
    class Obstacle {
        constructor(type) {
            this.type = type;
            this.x = canvas.width;
            this.width = X;
            this.height = type === 'rock' ? X / 2 : X / 2;
            this.y = type === 'rock' ? Math.random() > 0.5 ? canvas.height - X / 2 : canvas.height - X : canvas.height - this.height;
            this.speed = obstacleSpeed;
        }
        update() {
            this.x -= this.speed;
        }
        draw() {
            ctx.fillStyle = this.type === 'rock' ? 'gray' : 'brown';
            ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    }

    // Handle touch input
    window.addEventListener('touchstart', (e) => {
        startTouchY = e.touches[0].clientY;
    });

    window.addEventListener('touchmove', (e) => {
        const touchY = e.touches[0].clientY;
        const deltaY = touchY - startTouchY;

        if (deltaY < -30) {  // Swipe up
            yon.jump();
        } else if (deltaY > 30) {  // Swipe down
            yon.crouch();
        }
    });

    window.addEventListener('touchend', () => {
        yon.standUp();
    });

    // Reset game
    function resetGame() {
        isGameOver = false;
        score = 0;
        frameCount = 0;
        obstacles = [];
        obstacleSpeed = 5; // Reset speed
        lastSpeedIncreaseTime = 0;
        yon.y = canvas.height - yon.height;
        restartButton.style.display = 'none';
        update(); // Restart game loop
    }

    restartButton.addEventListener('click', resetGame);

    function generateObstacle() {
        const type = Math.random() > 0.5 ? 'rock' : 'hedgehog';
        obstacles.push(new Obstacle(type));
    }

    function updateScore() {
        score++;
        ctx.fillStyle = 'black';
        ctx.font = '24px Arial';
        ctx.fillText(`Score: ${score}`, 20, 40);
        ctx.fillText(`High Score: ${highScore}`, 20, 80);
    }

    function checkCollision() {
        for (let i = 0; i < obstacles.length; i++) {
            const obs = obstacles[i];
